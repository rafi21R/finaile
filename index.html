<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>2D Cover Shooter — Multiplayer</title>
<style>
  :root{
    --bg:#0f1724; --panel:#0b1220; --accent:#f97316; --muted:#94a3b8; --card:#071126;
    --player1:#60a5fa; --player2:#fb7185;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{background:linear-gradient(180deg,#020617 0%, #071029 100%); color:#cbd5e1; display:flex; align-items:flex-start; justify-content:center; padding:24px;}
  .wrap{width:1100px; max-width:95%; display:grid; grid-template-columns:1fr 340px; gap:18px;}
  .canvas-card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:14px; padding:12px; box-shadow: 0 6px 30px rgba(2,6,23,0.7);}
  canvas{display:block; width:100%; height:720px; background: linear-gradient(180deg,#07111b 0%, #0b1624 100%); border-radius:10px; image-rendering:optimizeSpeed;}
  .sidebar{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:14px; padding:16px; box-shadow:0 6px 30px rgba(2,6,23,0.7); height:720px; overflow:auto;}
  h1{font-size:18px;margin:0 0 8px 0;color:#e6eef8}
  .meta{font-size:13px;color:var(--muted);margin-bottom:12px}
  .controls{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;cursor:pointer;color:var(--muted);font-size:13px}
  .btn.primary{background:linear-gradient(90deg,var(--accent),#fb923c);color:#051023;border:0}
  .scoreboard{display:flex;gap:8px;align-items:center;margin-bottom:12px}
  .pill{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:999px;font-weight:600}
  .muted{color:var(--muted);font-size:13px}
  .rooms{margin-top:12px}
  .small{font-size:12px;color:var(--muted)}
  footer{margin-top:18px;color:var(--muted);font-size:12px;text-align:center}
  .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .legend .item{display:flex;align-items:center;gap:8px}
  .dot{width:12px;height:12px;border-radius:3px}
  .cover{background:#1f2937;border:1px solid rgba(255,255,255,0.04);box-shadow:inset 0 -6px 20px rgba(0,0,0,0.6);}
</style>
</head>
<body>
<div class="wrap">
  <div class="canvas-card">
    <h1>2D Cover Shooter — Multiplayer</h1>
    <div class="meta">WASD to move • Space to shoot • Use link sharing to play with anyone</div>
    <canvas id="gameCanvas" width="1200" height="720"></canvas>
  </div>

  <div class="sidebar">
    <h1>Controls & Info</h1>
    <div class="meta">Move: <b>W A S D</b> (or arrow keys). Shoot: <b>Space</b>. Aim with mouse. Avoid bullets and hide behind covers.</div>

    <div class="scoreboard">
      <div class="pill" id="youScore">You: 0</div>
      <div class="pill" id="otherScore">Opponent: 0</div>
    </div>

    <div class="controls">
      <button class="btn" id="btnToggleReady">Ready</button>
      <button class="btn primary" id="btnRespawn">Respawn</button>
    </div>

    <div class="rooms">
      <div class="small">Room link (share to play):</div>
      <div id="roomLink" class="small" style="word-break:break-all;margin-top:6px;color:#9ae6b4"></div>
      <div style="margin-top:10px" class="small muted">Connection: <span id="connState">—</span></div>
      <div style="margin-top:8px" class="legend">
        <div class="item"><div class="dot" style="background:var(--player1)"></div><div class="small">You</div></div>
        <div class="item"><div class="dot" style="background:var(--player2)"></div><div class="small">Opponent</div></div>
        <div class="item"><div class="dot cover"></div><div class="small">Cover / Obstacle</div></div>
      </div>
    </div>

    <footer>Built with Canvas + WebSocket • Minimal authoritative relay</footer>
  </div>
</div>

<script>
/* ============================
   Multiplayer 2D Cover Shooter
   Single-file client
   ============================ */

(() => {
  // Config
  const SERVER = (location.protocol === 'https:' ? 'wss://' : 'ws://') + (location.hostname || 'localhost') + ':8080';
  // Adjust above if server hosted elsewhere, e.g. wss://your-domain:8080

  // Canvas setup
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  const W = canvas.width, H = canvas.height;

  // UI elements
  const youScoreEl = document.getElementById('youScore');
  const otherScoreEl = document.getElementById('otherScore');
  const roomLinkEl = document.getElementById('roomLink');
  const connStateEl = document.getElementById('connState');
  const btnToggleReady = document.getElementById('btnToggleReady');
  const btnRespawn = document.getElementById('btnRespawn');

  // Networking & room
  const params = new URLSearchParams(location.search);
  let ROOM = params.get('room') || (Math.random().toString(36).slice(2,9));
  if (!params.get('room')) {
    const newURL = new URL(location.href);
    newURL.searchParams.set('room', ROOM);
    history.replaceState({}, '', newURL.toString());
  }
  roomLinkEl.textContent = location.href;

  // --- Game state ---
  const PLAYER_SIZE = 36;
  const BULLET_SPEED = 900; // px/sec
  const FIRE_COOLDOWN = 260; // ms
  const MAX_HP = 100;
  const COVER_COLOR = '#0b1520';

  const covers = [
    { x: 200, y: 220, w: 220, h: 36 },
    { x: 680, y: 140, w: 36, h: 260 },
    { x: 420, y: 420, w: 300, h: 40 },
    { x: 60, y: 520, w: 160, h: 36 },
    { x: 960, y: 300, w: 160, h: 36 },
  ];

  let localId = null;
  let ws = null;
  let connected = false;

  const players = {}; // keyed by id {x,y,ang,velx,vely,score,hp,ready}
  const bullets = []; // local bullets only
  const remoteBullets = []; // bullets from remote

  // Input
  const keys = {};
  let mouse = { x: W/2, y: H/2, down: false };

  // State variables
  let lastFrame = performance.now();
  let lastShotT = 0;

  // Initialize local player
  function spawnAsLocal() {
    if (!localId) return;
    players[localId] = {
      id: localId,
      x: Math.random() * (W-200) + 100,
      y: Math.random() * (H-200) + 100,
      vx:0, vy:0, ang:0,
      score: 0, hp: MAX_HP, alive:true, ready:false
    }
    send({ t: 'spawn', id: localId, x: players[localId].x, y: players[localId].y });
  }

  // Networking helpers
  function send(obj) {
    if (!ws || ws.readyState !== 1) return;
    obj.room = ROOM;
    ws.send(JSON.stringify(obj));
  }

  function connect() {
    ws = new WebSocket(SERVER + '/ws');
    connStateEl.textContent = 'connecting...';

    ws.onopen = () => {
      connected = true;
      connStateEl.textContent = 'connected';
      // register/join
      localId = Math.random().toString(36).slice(2,10);
      send({ t:'join', id: localId, room: ROOM });
      // spawn
      spawnAsLocal();
    };
    ws.onmessage = (ev) => {
      const data = JSON.parse(ev.data);
      handleMessage(data);
    };
    ws.onclose = () => {
      connected = false;
      connStateEl.textContent = 'disconnected';
      // Try reconnect after a pause
      setTimeout(connect, 1500);
    };
    ws.onerror = () => {
      connStateEl.textContent = 'error';
    };
  }

  function handleMessage(msg) {
    // messages: joined, state, peer-join, peer-leave, spawn, input, shoot, hit, score
    if (msg.t === 'joined') {
      // server acknowledges join
      // msg.otherPlayers list
      if (msg.players) {
        for (const p of msg.players) {
          if (p.id === localId) continue;
          players[p.id] = { ...p, vx:0, vy:0, ang:0, score:p.score || 0, hp: p.hp || MAX_HP, alive:true };
        }
      }
    } else if (msg.t === 'peer-join') {
      if (msg.id === localId) return;
      players[msg.id] = { id: msg.id, x: msg.x||100, y: msg.y||100, vx:0, vy:0, ang:0, score:0, hp:MAX_HP, alive:true };
    } else if (msg.t === 'peer-leave') {
      delete players[msg.id];
    } else if (msg.t === 'state') {
      // remote player state updates
      if (msg.id && msg.id !== localId) {
        const p = players[msg.id] || (players[msg.id] = { id: msg.id, vx:0,vy:0,score:0,hp:MAX_HP,alive:true });
        p.x = msg.x; p.y = msg.y; p.ang = msg.ang; p.hp = msg.hp; p.alive = msg.alive; p.score = msg.score;
      }
    } else if (msg.t === 'spawn') {
      if (msg.id === localId) return;
      players[msg.id] = { id: msg.id, x: msg.x, y: msg.y, vx:0, vy:0, ang:0, score:0, hp:MAX_HP, alive:true };
    } else if (msg.t === 'shoot') {
      // create bullet from remote
      if (msg.id === localId) return;
      remoteBullets.push({
        id: Math.random().toString(36).slice(2,9),
        x: msg.x, y: msg.y, vx: Math.cos(msg.ang)*BULLET_SPEED, vy: Math.sin(msg.ang)*BULLET_SPEED,
        owner: msg.id, created: performance.now()
      });
    } else if (msg.t === 'hit') {
      // server can relay hits; for now update score/hp
      const victim = players[msg.victim];
      if (victim) {
        victim.hp = msg.hp;
        if (!victim.alive && msg.killer) {
          // someone died
          if (msg.killer === localId) players[localId].score = (players[localId].score||0) + 1;
          if (msg.victim === localId && msg.killer) {
            // you died
          }
        }
      }
    } else if (msg.t === 'score') {
      if (msg.id && players[msg.id]) players[msg.id].score = msg.score;
    }
  }

  // Physics helpers
  function rectsOverlap(a,b){ return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h); }

  // shooting
  function tryShoot() {
    const now = performance.now();
    if (now - lastShotT < FIRE_COOLDOWN) return;
    lastShotT = now;
    const p = players[localId];
    if (!p || !p.alive) return;
    const ang = Math.atan2(mouse.y - p.y, mouse.x - p.x);
    const bx = p.x + Math.cos(ang) * (PLAYER_SIZE/2 + 6);
    const by = p.y + Math.sin(ang) * (PLAYER_SIZE/2 + 6);
    // local bullet
    bullets.push({ id: Math.random().toString(36).slice(2,9), x:bx, y:by, vx:Math.cos(ang)*BULLET_SPEED, vy:Math.sin(ang)*BULLET_SPEED, owner:localId, created:now });
    send({ t:'shoot', id: localId, x:bx, y:by, ang:ang, ts: now });
  }

  // Collision check with covers (simple AABB)
  function bulletHitsCover(b) {
    for (const c of covers) {
      if (b.x > c.x && b.x < c.x + c.w && b.y > c.y && b.y < c.y + c.h) return true;
    }
    return false;
  }

  // Bullet vs player
  function checkBulletHitsPlayer(b, player) {
    if (!player || !player.alive) return false;
    const dx = b.x - player.x;
    const dy = b.y - player.y;
    const dist2 = dx*dx + dy*dy;
    const r = PLAYER_SIZE*0.6;
    return dist2 <= r*r;
  }

  // Particle system for blood
  const particles = [];
  function spawnBlood(x,y,dir, amt=12) {
    for (let i=0;i<amt;i++){
      const sp = {
        x,y,
        vx: (Math.cos(dir) * (Math.random()*220 + 80) + (Math.random()-0.5)*200) * 0.008,
        vy: (Math.sin(dir) * (Math.random()*220 + 80) + (Math.random()-0.5)*200) * 0.008,
        life: Math.random()*700 + 300,
        created: performance.now(),
        size: Math.random()*4 + 2
      };
      particles.push(sp);
    }
  }

  // main loop
  function update(dt) {
    // handle input for local player
    const p = players[localId];
    if (p && p.alive) {
      const speed = 200; // px/sec
      let dx=0, dy=0;
      if (keys['w']||keys['ArrowUp']) dy -= 1;
      if (keys['s']||keys['ArrowDown']) dy += 1;
      if (keys['a']||keys['ArrowLeft']) dx -= 1;
      if (keys['d']||keys['ArrowRight']) dx += 1;
      // normalize
      if (dx !== 0 || dy !== 0) {
        const len = Math.hypot(dx,dy);
        dx/=len; dy/=len;
      }
      // move and collision with covers
      let nx = p.x + dx * speed * dt;
      let ny = p.y + dy * speed * dt;
      // bounding
      nx = Math.max(20, Math.min(W-20, nx));
      ny = Math.max(20, Math.min(H-20, ny));
      // check against covers (simple separate axis)
      const pbox = { x: nx-PLAYER_SIZE/2, y: ny-PLAYER_SIZE/2, w: PLAYER_SIZE, h: PLAYER_SIZE };
      let collided = false;
      for (const c of covers) {
        if (rectsOverlap(pbox, c)) { collided = true; break; }
      }
      if (!collided) { p.x = nx; p.y = ny; }
      p.ang = Math.atan2(mouse.y - p.y, mouse.x - p.x);

      // shooting
      if (keys[' '] || mouse.down) {
        tryShoot();
      }

      // send periodic state to server
      send({ t:'state', id:localId, x:p.x, y:p.y, ang:p.ang, hp:p.hp, alive:p.alive, score:p.score });
    }

    // update bullets (local)
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      // lifetime or out of bounds
      if (b.x < -20 || b.x > W+20 || b.y < -20 || b.y > H+20) { bullets.splice(i,1); continue; }
      if (bulletHitsCover(b)) { bullets.splice(i,1); continue; }
      // hit remote players
      for (const id in players) {
        if (id === localId) continue;
        const t = players[id];
        if (checkBulletHitsPlayer(b, t)) {
          // report hit to server
          send({ t:'hit', id: localId, victim: id, dmg: 30, ts: performance.now() });
          // local spawn blood
          spawnBlood(b.x, b.y, Math.atan2(b.vy, b.vx));
          bullets.splice(i,1);
          break;
        }
      }
      // hit local player if owned by remote
      if (b.owner !== localId) {
        if (checkBulletHitsPlayer(b, players[localId])) {
          // local got hit
          players[localId].hp -= 30;
          spawnBlood(b.x, b.y, Math.atan2(b.vy, b.vx)+Math.PI);
          bullets.splice(i,1);
          // notify server
          send({ t:'hit', id: localId, victim: localId, dmg: 30, killer: b.owner, ts: performance.now() });
        }
      }
    }

    // remote bullets update
    for (let i = remoteBullets.length - 1; i >= 0; i--) {
      const b = remoteBullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      if (b.x < -20 || b.x > W+20 || b.y < -20 || b.y > H+20) { remoteBullets.splice(i,1); continue; }
      if (bulletHitsCover(b)) { remoteBullets.splice(i,1); continue; }
      if (checkBulletHitsPlayer(b, players[localId])) {
        players[localId].hp -= 30;
        spawnBlood(b.x, b.y, Math.atan2(b.vy, b.vx)+Math.PI);
        remoteBullets.splice(i,1);
        send({ t:'hit', id: localId, victim: localId, dmg: 30, killer: b.owner, ts: performance.now() });
      }
    }

    // update particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const q = particles[i];
      const age = performance.now() - q.created;
      if (age > q.life) { particles.splice(i,1); continue; }
      q.x += q.vx * dt * 1000;
      q.y += q.vy * dt * 1000;
      q.vy += 0.002 * dt * 1000; // gravity tiny
    }

    // death + respawn logic
    for (const id in players) {
      const pl = players[id];
      if (pl.hp <= 0 && pl.alive) {
        pl.alive = false;
        // if killed, award scorer handled by server; here we just mark
        // schedule respawn automatically after a while
        setTimeout(() => {
          if (players[id]) {
            players[id].hp = MAX_HP;
            players[id].alive = true;
            players[id].x = Math.random()*(W-200)+100;
            players[id].y = Math.random()*(H-200)+100;
            send({ t:'spawn', id: id, x: players[id].x, y: players[id].y });
          }
        }, 2000);
      }
    }

    // update scoreboard UI
    if (players[localId]) youScoreEl.textContent = `You: ${players[localId].score || 0}`;
    // show other player's score if present (first other)
    const otherId = Object.keys(players).find(id => id !== localId);
    if (otherId) otherScoreEl.textContent = `Opponent: ${players[otherId].score || 0}`;
    else otherScoreEl.textContent = 'Opponent: —';
  }

  function render() {
    // clear
    ctx.fillStyle = '#07121b';
    ctx.fillRect(0,0,W,H);

    // grid background subtle
    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = '#1b2836';
    for (let gx=0; gx< W; gx+=64) {
      ctx.fillRect(gx, 0, 1, H);
    }
    for (let gy=0; gy<H; gy+=64) {
      ctx.fillRect(0, gy, W, 1);
    }
    ctx.restore();

    // draw covers
    for (const c of covers) {
      ctx.fillStyle = COVER_COLOR;
      ctx.fillRect(c.x, c.y, c.w, c.h);
      // slight bevel
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.strokeRect(c.x, c.y, c.w, c.h);
    }

    // draw bullets (remote and local)
    function drawBullet(b, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.arc(b.x, b.y, 4, 0, Math.PI*2);
      ctx.fill();
    }
    for (const b of bullets) drawBullet(b, '#ffd166');
    for (const b of remoteBullets) drawBullet(b, '#ff6b6b');

    // draw players
    for (const id in players) {
      const pl = players[id];
      if (!pl) continue;
      // shadow
      ctx.beginPath();
      ctx.ellipse(pl.x, pl.y + PLAYER_SIZE/2 + 4, PLAYER_SIZE/1.8, PLAYER_SIZE/3.2, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fill();

      // body
      ctx.save();
      ctx.translate(pl.x, pl.y);
      ctx.rotate(pl.ang);
      // rectangle body
      ctx.fillStyle = (id === localId) ? getComputedStyle(document.documentElement).getPropertyValue('--player1') : getComputedStyle(document.documentElement).getPropertyValue('--player2');
      if (!pl.alive) ctx.globalAlpha = 0.25;
      ctx.fillRect(-PLAYER_SIZE/2, -PLAYER_SIZE/2, PLAYER_SIZE, PLAYER_SIZE);
      // gun stub
      ctx.fillStyle = '#0b1220';
      ctx.fillRect(0, -6, PLAYER_SIZE/1.7, 12);
      ctx.restore();

      // health bar
      const hpPct = Math.max(0, pl.hp)/MAX_HP;
      const barW = 84;
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(pl.x - barW/2, pl.y - PLAYER_SIZE/2 - 12, barW, 8);
      ctx.fillStyle = `linear-gradient(90deg,#0f766e, #ef4444)`; // fallback not supported — draw with fillRect
      ctx.fillStyle = `rgba(255,100,60,0.9)`;
      ctx.fillRect(pl.x - barW/2, pl.y - PLAYER_SIZE/2 - 12, barW * hpPct, 8);
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.strokeRect(pl.x - barW/2, pl.y - PLAYER_SIZE/2 - 12, barW, 8);

      // name & score
      ctx.fillStyle = '#cbd5e1';
      ctx.font = '12px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText((id === localId ? 'You' : 'Opponent') + ' • ' + (pl.score||0), pl.x, pl.y + PLAYER_SIZE/2 + 18);
    }

    // particles (blood)
    for (const q of particles) {
      const age = performance.now() - q.created;
      const t = age / q.life;
      const alpha = 1 - t;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#ff3b3b';
      ctx.beginPath();
      ctx.arc(q.x, q.y, q.size, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // HUD crosshair
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.moveTo(mouse.x - 8, mouse.y);
    ctx.lineTo(mouse.x + 8, mouse.y);
    ctx.moveTo(mouse.x, mouse.y - 8);
    ctx.lineTo(mouse.x, mouse.y + 8);
    ctx.stroke();

    // mini scoreboard top-left
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(12, 12, 210, 44);
    ctx.fillStyle = '#fff';
    ctx.font = '14px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#cbd5e1';
    const me = players[localId];
    ctx.fillText(`You: ${me ? (me.score||0) : 0}  HP: ${me ? Math.max(0, Math.round(me.hp)) : 0}`, 22, 34);
    const otherId = Object.keys(players).find(id=>id!==localId);
    const o = otherId ? players[otherId] : null;
    ctx.fillText(`Opp: ${o ? (o.score||0) : '—' }`, 140, 34);
  }

  // main animate
  function tick(now) {
    const dt = Math.min(40, now - lastFrame) / 1000;
    lastFrame = now;
    update(dt);
    render();
    requestAnimationFrame(tick);
  }

  // Input handlers
  window.addEventListener('keydown', (e) => {
    if (e.key === ' '){ e.preventDefault(); keys[' '] = true; }
    keys[e.key] = true;
  });
  window.addEventListener('keyup', (e) => { keys[e.key] = false; if (e.key === ' ') keys[' '] = false; });
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
  });
  canvas.addEventListener('mousedown', (e) => { mouse.down = true; });
  window.addEventListener('mouseup', () => { mouse.down = false; });

  btnToggleReady.addEventListener('click', () => {
    if (!players[localId]) return;
    players[localId].ready = !players[localId].ready;
    btnToggleReady.textContent = players[localId].ready ? 'Unready' : 'Ready';
    send({ t:'ready', id: localId, ready: players[localId].ready });
  });

  btnRespawn.addEventListener('click', () => {
    if (!players[localId]) return;
    players[localId].hp = MAX_HP; players[localId].alive = true;
    spawnAsLocal();
    send({ t:'spawn', id: localId, x: players[localId].x, y: players[localId].y });
  });

  // Start
  connect();
  requestAnimationFrame((t) => { lastFrame = t; requestAnimationFrame(tick); });

  // small safety: if user closes, notify server
  window.addEventListener('beforeunload', () => { if (ws && ws.readyState === 1) ws.close(); });

})();
</script>
</body>
</html>
